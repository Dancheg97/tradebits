// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InfoClient is the client API for Info service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InfoClient interface {
	User(ctx context.Context, in *InfIn_Adress, opts ...grpc.CallOption) (*InfOut_User, error)
	HasTrades(ctx context.Context, in *InfIn_UserMarketAdresses, opts ...grpc.CallOption) (*InfOut_Bool, error)
	Market(ctx context.Context, in *InfIn_Adress, opts ...grpc.CallOption) (*InfOut_MarketInfo, error)
	Search(ctx context.Context, in *InfIn_Text, opts ...grpc.CallOption) (*InfOut_Adresses, error)
	Messages(ctx context.Context, in *InfIn_UserMarketAdresses, opts ...grpc.CallOption) (*InfOut_Messages, error)
	CheckName(ctx context.Context, in *InfIn_Text, opts ...grpc.CallOption) (*InfOut_Bool, error)
}

type infoClient struct {
	cc grpc.ClientConnInterface
}

func NewInfoClient(cc grpc.ClientConnInterface) InfoClient {
	return &infoClient{cc}
}

func (c *infoClient) User(ctx context.Context, in *InfIn_Adress, opts ...grpc.CallOption) (*InfOut_User, error) {
	out := new(InfOut_User)
	err := c.cc.Invoke(ctx, "/api.Info/User", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoClient) HasTrades(ctx context.Context, in *InfIn_UserMarketAdresses, opts ...grpc.CallOption) (*InfOut_Bool, error) {
	out := new(InfOut_Bool)
	err := c.cc.Invoke(ctx, "/api.Info/HasTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoClient) Market(ctx context.Context, in *InfIn_Adress, opts ...grpc.CallOption) (*InfOut_MarketInfo, error) {
	out := new(InfOut_MarketInfo)
	err := c.cc.Invoke(ctx, "/api.Info/Market", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoClient) Search(ctx context.Context, in *InfIn_Text, opts ...grpc.CallOption) (*InfOut_Adresses, error) {
	out := new(InfOut_Adresses)
	err := c.cc.Invoke(ctx, "/api.Info/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoClient) Messages(ctx context.Context, in *InfIn_UserMarketAdresses, opts ...grpc.CallOption) (*InfOut_Messages, error) {
	out := new(InfOut_Messages)
	err := c.cc.Invoke(ctx, "/api.Info/Messages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoClient) CheckName(ctx context.Context, in *InfIn_Text, opts ...grpc.CallOption) (*InfOut_Bool, error) {
	out := new(InfOut_Bool)
	err := c.cc.Invoke(ctx, "/api.Info/CheckName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfoServer is the server API for Info service.
// All implementations must embed UnimplementedInfoServer
// for forward compatibility
type InfoServer interface {
	User(context.Context, *InfIn_Adress) (*InfOut_User, error)
	HasTrades(context.Context, *InfIn_UserMarketAdresses) (*InfOut_Bool, error)
	Market(context.Context, *InfIn_Adress) (*InfOut_MarketInfo, error)
	Search(context.Context, *InfIn_Text) (*InfOut_Adresses, error)
	Messages(context.Context, *InfIn_UserMarketAdresses) (*InfOut_Messages, error)
	CheckName(context.Context, *InfIn_Text) (*InfOut_Bool, error)
	mustEmbedUnimplementedInfoServer()
}

// UnimplementedInfoServer must be embedded to have forward compatible implementations.
type UnimplementedInfoServer struct {
}

func (UnimplementedInfoServer) User(context.Context, *InfIn_Adress) (*InfOut_User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method User not implemented")
}
func (UnimplementedInfoServer) HasTrades(context.Context, *InfIn_UserMarketAdresses) (*InfOut_Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasTrades not implemented")
}
func (UnimplementedInfoServer) Market(context.Context, *InfIn_Adress) (*InfOut_MarketInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Market not implemented")
}
func (UnimplementedInfoServer) Search(context.Context, *InfIn_Text) (*InfOut_Adresses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedInfoServer) Messages(context.Context, *InfIn_UserMarketAdresses) (*InfOut_Messages, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Messages not implemented")
}
func (UnimplementedInfoServer) CheckName(context.Context, *InfIn_Text) (*InfOut_Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckName not implemented")
}
func (UnimplementedInfoServer) mustEmbedUnimplementedInfoServer() {}

// UnsafeInfoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InfoServer will
// result in compilation errors.
type UnsafeInfoServer interface {
	mustEmbedUnimplementedInfoServer()
}

func RegisterInfoServer(s grpc.ServiceRegistrar, srv InfoServer) {
	s.RegisterService(&Info_ServiceDesc, srv)
}

func _Info_User_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfIn_Adress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServer).User(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Info/User",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServer).User(ctx, req.(*InfIn_Adress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Info_HasTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfIn_UserMarketAdresses)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServer).HasTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Info/HasTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServer).HasTrades(ctx, req.(*InfIn_UserMarketAdresses))
	}
	return interceptor(ctx, in, info, handler)
}

func _Info_Market_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfIn_Adress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServer).Market(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Info/Market",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServer).Market(ctx, req.(*InfIn_Adress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Info_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfIn_Text)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Info/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServer).Search(ctx, req.(*InfIn_Text))
	}
	return interceptor(ctx, in, info, handler)
}

func _Info_Messages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfIn_UserMarketAdresses)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServer).Messages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Info/Messages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServer).Messages(ctx, req.(*InfIn_UserMarketAdresses))
	}
	return interceptor(ctx, in, info, handler)
}

func _Info_CheckName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfIn_Text)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServer).CheckName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Info/CheckName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServer).CheckName(ctx, req.(*InfIn_Text))
	}
	return interceptor(ctx, in, info, handler)
}

// Info_ServiceDesc is the grpc.ServiceDesc for Info service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Info_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Info",
	HandlerType: (*InfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "User",
			Handler:    _Info_User_Handler,
		},
		{
			MethodName: "HasTrades",
			Handler:    _Info_HasTrades_Handler,
		},
		{
			MethodName: "Market",
			Handler:    _Info_Market_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _Info_Search_Handler,
		},
		{
			MethodName: "Messages",
			Handler:    _Info_Messages_Handler,
		},
		{
			MethodName: "CheckName",
			Handler:    _Info_CheckName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	Create(ctx context.Context, in *UserRequests_Create, opts ...grpc.CallOption) (*Response, error)
	Send(ctx context.Context, in *UserRequests_Send, opts ...grpc.CallOption) (*Response, error)
	Message(ctx context.Context, in *UserRequests_Message, opts ...grpc.CallOption) (*Response, error)
	Buy(ctx context.Context, in *UserRequests_Trade, opts ...grpc.CallOption) (*Response, error)
	Sell(ctx context.Context, in *UserRequests_Trade, opts ...grpc.CallOption) (*Response, error)
	CancelTrade(ctx context.Context, in *UserRequests_CancelTrade, opts ...grpc.CallOption) (*Response, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) Create(ctx context.Context, in *UserRequests_Create, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.User/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Send(ctx context.Context, in *UserRequests_Send, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.User/Send", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Message(ctx context.Context, in *UserRequests_Message, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.User/Message", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Buy(ctx context.Context, in *UserRequests_Trade, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.User/Buy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Sell(ctx context.Context, in *UserRequests_Trade, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.User/Sell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) CancelTrade(ctx context.Context, in *UserRequests_CancelTrade, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.User/CancelTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	Create(context.Context, *UserRequests_Create) (*Response, error)
	Send(context.Context, *UserRequests_Send) (*Response, error)
	Message(context.Context, *UserRequests_Message) (*Response, error)
	Buy(context.Context, *UserRequests_Trade) (*Response, error)
	Sell(context.Context, *UserRequests_Trade) (*Response, error)
	CancelTrade(context.Context, *UserRequests_CancelTrade) (*Response, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) Create(context.Context, *UserRequests_Create) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedUserServer) Send(context.Context, *UserRequests_Send) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedUserServer) Message(context.Context, *UserRequests_Message) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Message not implemented")
}
func (UnimplementedUserServer) Buy(context.Context, *UserRequests_Trade) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Buy not implemented")
}
func (UnimplementedUserServer) Sell(context.Context, *UserRequests_Trade) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sell not implemented")
}
func (UnimplementedUserServer) CancelTrade(context.Context, *UserRequests_CancelTrade) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTrade not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequests_Create)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Create(ctx, req.(*UserRequests_Create))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequests_Send)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Send(ctx, req.(*UserRequests_Send))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Message_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequests_Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Message(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Message",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Message(ctx, req.(*UserRequests_Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Buy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequests_Trade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Buy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Buy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Buy(ctx, req.(*UserRequests_Trade))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Sell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequests_Trade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Sell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/Sell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Sell(ctx, req.(*UserRequests_Trade))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_CancelTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequests_CancelTrade)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).CancelTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.User/CancelTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).CancelTrade(ctx, req.(*UserRequests_CancelTrade))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _User_Create_Handler,
		},
		{
			MethodName: "Send",
			Handler:    _User_Send_Handler,
		},
		{
			MethodName: "Message",
			Handler:    _User_Message_Handler,
		},
		{
			MethodName: "Buy",
			Handler:    _User_Buy_Handler,
		},
		{
			MethodName: "Sell",
			Handler:    _User_Sell_Handler,
		},
		{
			MethodName: "CancelTrade",
			Handler:    _User_CancelTrade_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// MarketClient is the client API for Market service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MarketClient interface {
	Spawn(ctx context.Context, in *MarketRequests_Create, opts ...grpc.CallOption) (*Response, error)
	Update(ctx context.Context, in *MarketRequests_Update, opts ...grpc.CallOption) (*Response, error)
	Deposit(ctx context.Context, in *MarketRequests_Deposit, opts ...grpc.CallOption) (*Response, error)
	Withdrawal(ctx context.Context, in *MarketRequests_Withdrawal, opts ...grpc.CallOption) (*Response, error)
	Reply(ctx context.Context, in *MarketRequests_Message, opts ...grpc.CallOption) (*Response, error)
}

type marketClient struct {
	cc grpc.ClientConnInterface
}

func NewMarketClient(cc grpc.ClientConnInterface) MarketClient {
	return &marketClient{cc}
}

func (c *marketClient) Spawn(ctx context.Context, in *MarketRequests_Create, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.Market/Spawn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketClient) Update(ctx context.Context, in *MarketRequests_Update, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.Market/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketClient) Deposit(ctx context.Context, in *MarketRequests_Deposit, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.Market/Deposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketClient) Withdrawal(ctx context.Context, in *MarketRequests_Withdrawal, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.Market/Withdrawal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marketClient) Reply(ctx context.Context, in *MarketRequests_Message, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/api.Market/Reply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MarketServer is the server API for Market service.
// All implementations must embed UnimplementedMarketServer
// for forward compatibility
type MarketServer interface {
	Spawn(context.Context, *MarketRequests_Create) (*Response, error)
	Update(context.Context, *MarketRequests_Update) (*Response, error)
	Deposit(context.Context, *MarketRequests_Deposit) (*Response, error)
	Withdrawal(context.Context, *MarketRequests_Withdrawal) (*Response, error)
	Reply(context.Context, *MarketRequests_Message) (*Response, error)
	mustEmbedUnimplementedMarketServer()
}

// UnimplementedMarketServer must be embedded to have forward compatible implementations.
type UnimplementedMarketServer struct {
}

func (UnimplementedMarketServer) Spawn(context.Context, *MarketRequests_Create) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Spawn not implemented")
}
func (UnimplementedMarketServer) Update(context.Context, *MarketRequests_Update) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedMarketServer) Deposit(context.Context, *MarketRequests_Deposit) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (UnimplementedMarketServer) Withdrawal(context.Context, *MarketRequests_Withdrawal) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdrawal not implemented")
}
func (UnimplementedMarketServer) Reply(context.Context, *MarketRequests_Message) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reply not implemented")
}
func (UnimplementedMarketServer) mustEmbedUnimplementedMarketServer() {}

// UnsafeMarketServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MarketServer will
// result in compilation errors.
type UnsafeMarketServer interface {
	mustEmbedUnimplementedMarketServer()
}

func RegisterMarketServer(s grpc.ServiceRegistrar, srv MarketServer) {
	s.RegisterService(&Market_ServiceDesc, srv)
}

func _Market_Spawn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketRequests_Create)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketServer).Spawn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Market/Spawn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketServer).Spawn(ctx, req.(*MarketRequests_Create))
	}
	return interceptor(ctx, in, info, handler)
}

func _Market_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketRequests_Update)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Market/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketServer).Update(ctx, req.(*MarketRequests_Update))
	}
	return interceptor(ctx, in, info, handler)
}

func _Market_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketRequests_Deposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Market/Deposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketServer).Deposit(ctx, req.(*MarketRequests_Deposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Market_Withdrawal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketRequests_Withdrawal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketServer).Withdrawal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Market/Withdrawal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketServer).Withdrawal(ctx, req.(*MarketRequests_Withdrawal))
	}
	return interceptor(ctx, in, info, handler)
}

func _Market_Reply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarketRequests_Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketServer).Reply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Market/Reply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketServer).Reply(ctx, req.(*MarketRequests_Message))
	}
	return interceptor(ctx, in, info, handler)
}

// Market_ServiceDesc is the grpc.ServiceDesc for Market service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Market_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Market",
	HandlerType: (*MarketServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Spawn",
			Handler:    _Market_Spawn_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Market_Update_Handler,
		},
		{
			MethodName: "Deposit",
			Handler:    _Market_Deposit_Handler,
		},
		{
			MethodName: "Withdrawal",
			Handler:    _Market_Withdrawal_Handler,
		},
		{
			MethodName: "Reply",
			Handler:    _Market_Reply_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// ConnectionClient is the client API for Connection service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConnectionClient interface {
	Connect(ctx context.Context, in *ConnectionRequests_In, opts ...grpc.CallOption) (Connection_ConnectClient, error)
	Pool(ctx context.Context, in *ConnectionRequests_Pool, opts ...grpc.CallOption) (*ConnectionRequests_Pool, error)
}

type connectionClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectionClient(cc grpc.ClientConnInterface) ConnectionClient {
	return &connectionClient{cc}
}

func (c *connectionClient) Connect(ctx context.Context, in *ConnectionRequests_In, opts ...grpc.CallOption) (Connection_ConnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &Connection_ServiceDesc.Streams[0], "/api.Connection/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &connectionConnectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Connection_ConnectClient interface {
	Recv() (*ConnectionRequests_Out, error)
	grpc.ClientStream
}

type connectionConnectClient struct {
	grpc.ClientStream
}

func (x *connectionConnectClient) Recv() (*ConnectionRequests_Out, error) {
	m := new(ConnectionRequests_Out)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *connectionClient) Pool(ctx context.Context, in *ConnectionRequests_Pool, opts ...grpc.CallOption) (*ConnectionRequests_Pool, error) {
	out := new(ConnectionRequests_Pool)
	err := c.cc.Invoke(ctx, "/api.Connection/Pool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectionServer is the server API for Connection service.
// All implementations must embed UnimplementedConnectionServer
// for forward compatibility
type ConnectionServer interface {
	Connect(*ConnectionRequests_In, Connection_ConnectServer) error
	Pool(context.Context, *ConnectionRequests_Pool) (*ConnectionRequests_Pool, error)
	mustEmbedUnimplementedConnectionServer()
}

// UnimplementedConnectionServer must be embedded to have forward compatible implementations.
type UnimplementedConnectionServer struct {
}

func (UnimplementedConnectionServer) Connect(*ConnectionRequests_In, Connection_ConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedConnectionServer) Pool(context.Context, *ConnectionRequests_Pool) (*ConnectionRequests_Pool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pool not implemented")
}
func (UnimplementedConnectionServer) mustEmbedUnimplementedConnectionServer() {}

// UnsafeConnectionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectionServer will
// result in compilation errors.
type UnsafeConnectionServer interface {
	mustEmbedUnimplementedConnectionServer()
}

func RegisterConnectionServer(s grpc.ServiceRegistrar, srv ConnectionServer) {
	s.RegisterService(&Connection_ServiceDesc, srv)
}

func _Connection_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConnectionRequests_In)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConnectionServer).Connect(m, &connectionConnectServer{stream})
}

type Connection_ConnectServer interface {
	Send(*ConnectionRequests_Out) error
	grpc.ServerStream
}

type connectionConnectServer struct {
	grpc.ServerStream
}

func (x *connectionConnectServer) Send(m *ConnectionRequests_Out) error {
	return x.ServerStream.SendMsg(m)
}

func _Connection_Pool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectionRequests_Pool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionServer).Pool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Connection/Pool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionServer).Pool(ctx, req.(*ConnectionRequests_Pool))
	}
	return interceptor(ctx, in, info, handler)
}

// Connection_ServiceDesc is the grpc.ServiceDesc for Connection service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Connection_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Connection",
	HandlerType: (*ConnectionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Pool",
			Handler:    _Connection_Pool_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _Connection_Connect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/api.proto",
}
